import { describe, expect, it } from "vitest";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "../..");

// Minimum percentage of blank lines required (5% = 1 blank line per 20 lines)
const MIN_BLANK_LINE_RATIO = 0.05;

// Files to skip (auto-generated, data files, etc.)
const SKIP_FILES = new Set([
  "gain-lookup-table.js", // Auto-generated lookup table
  "barbeat-parser.js", // Generated by peggy
  "modulation-parser.js", // Generated by peggy
]);

// File patterns to skip
const SKIP_PATTERNS = [
  /\.def\.js$/, // Tool definition files (declarative, don't need blank lines)
  /\.test\.(js|ts|tsx)$/, // Test files (often have dense test data)
  /\.d\.ts$/, // TypeScript declaration files
];

// Directories to skip entirely
const SKIP_DIRECTORIES = new Set([
  "test-cases", // Test fixture data
]);

// File extensions to check
const SOURCE_EXTENSIONS = new Set([".js", ".ts", ".jsx", ".tsx"]);

/**
 * Calculate the blank line ratio for a file
 * @param {string} filePath - Path to the file
 * @returns {{totalLines: number, blankLines: number, ratio: number}} Line statistics
 */
function calculateBlankLineRatio(filePath) {
  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split("\n");
  const totalLines = lines.length;
  const blankLines = lines.filter((line) => line.trim() === "").length;
  const ratio = totalLines > 0 ? blankLines / totalLines : 0;

  return { totalLines, blankLines, ratio };
}

/**
 * Check if a file should be skipped based on patterns
 * @param {string} fileName - File name to check
 * @returns {boolean} True if file should be skipped
 */
function shouldSkipFile(fileName) {
  if (SKIP_FILES.has(fileName)) return true;

  return SKIP_PATTERNS.some((pattern) => pattern.test(fileName));
}

/**
 * Recursively find source files with insufficient blank lines
 * @param {string} dirPath - Directory to scan
 * @param {string[]} excludeDirs - Directory names to exclude
 * @returns {Array<{path: string, ratio: number, blankLines: number, totalLines: number}>} Files below threshold
 */
function findFilesWithInsufficientBlankLines(dirPath, excludeDirs = []) {
  const results = [];

  if (!fs.existsSync(dirPath)) {
    return results;
  }

  const items = fs.readdirSync(dirPath);

  for (const item of items) {
    if (excludeDirs.includes(item)) continue;
    if (SKIP_DIRECTORIES.has(item)) continue;

    const fullPath = path.join(dirPath, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      results.push(
        ...findFilesWithInsufficientBlankLines(fullPath, excludeDirs),
      );
    } else if (stat.isFile()) {
      const ext = path.extname(item);

      if (!SOURCE_EXTENSIONS.has(ext)) continue;
      if (shouldSkipFile(item)) continue;

      const stats = calculateBlankLineRatio(fullPath);

      // Only check files with meaningful content (at least 20 lines)
      if (stats.totalLines >= 20 && stats.ratio < MIN_BLANK_LINE_RATIO) {
        results.push({
          path: path.relative(projectRoot, fullPath),
          ratio: stats.ratio,
          blankLines: stats.blankLines,
          totalLines: stats.totalLines,
        });
      }
    }
  }

  return results;
}

/**
 * Assert that all files in a directory meet the minimum blank line ratio
 * @param {string} dirPath - Directory to check
 */
function assertBlankLineRatio(dirPath) {
  const insufficientFiles = findFilesWithInsufficientBlankLines(dirPath, [
    "node_modules",
  ]);

  if (insufficientFiles.length > 0) {
    const details = insufficientFiles
      .sort((a, b) => a.ratio - b.ratio)
      .map(
        (f) =>
          `  - ${f.path}: ${(f.ratio * 100).toFixed(1)}% blank (${f.blankLines}/${f.totalLines} lines)`,
      )
      .join("\n");

    expect.fail(
      `Found ${insufficientFiles.length} file(s) with less than ${MIN_BLANK_LINE_RATIO * 100}% blank lines:\n${details}\n\n` +
        `Add blank lines between logical sections to improve readability.`,
    );
  }

  expect(insufficientFiles).toHaveLength(0);
}

describe("Blank line requirements", () => {
  it.each([
    ["src/", ["src"]],
    ["webui/src/", ["webui", "src"]],
    ["scripts/", ["scripts"]],
  ])("should enforce minimum blank line ratio in %s", (_name, pathParts) => {
    const dirPath = path.join(projectRoot, ...pathParts);

    assertBlankLineRatio(dirPath);
    expect(true).toBe(true); // Satisfy vitest/expect-expect rule
  });
});
