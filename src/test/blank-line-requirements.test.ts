import { describe, expect, it } from "vitest";
import fs from "node:fs";
import path from "node:path";
import { projectRoot } from "./helpers/meta-test-helpers.ts";

// Minimum percentage of blank lines required (5% = 1 blank line per 20 lines)
const MIN_BLANK_LINE_RATIO = 0.05;

// Files to skip (auto-generated, data files, etc.)
const SKIP_FILES = new Set([
  "clip-gain-lookup-table.ts", // Generated lookup table
]);

// File patterns to skip
const SKIP_PATTERNS = [
  /^generated-.*-parser\.js$/, // Generated by peggy
  /\.def\.js$/, // Tool definition files (declarative, don't need blank lines)
  /\.test\.(js|ts|tsx)$/, // Test files (often have dense test data)
  /\.d\.ts$/, // TypeScript declaration files
];

// Directories to skip entirely
const SKIP_DIRECTORIES = new Set([
  "test-cases", // Test fixture data
]);

// File extensions to check
const SOURCE_EXTENSIONS = new Set([".js", ".ts", ".jsx", ".tsx"]);

interface BlankLineStats {
  totalLines: number;
  blankLines: number;
  ratio: number;
}

interface FileResult {
  path: string;
  ratio: number;
  blankLines: number;
  totalLines: number;
}

function calculateBlankLineRatio(filePath: string): BlankLineStats {
  const content = fs.readFileSync(filePath, "utf-8");
  const lines = content.split("\n");
  const totalLines = lines.length;
  const blankLines = lines.filter((line) => line.trim() === "").length;
  const ratio = totalLines > 0 ? blankLines / totalLines : 0;

  return { totalLines, blankLines, ratio };
}

function shouldSkipFile(fileName: string): boolean {
  if (SKIP_FILES.has(fileName)) return true;

  return SKIP_PATTERNS.some((pattern) => pattern.test(fileName));
}

function findFilesWithInsufficientBlankLines(
  dirPath: string,
  excludeDirs: string[] = [],
): FileResult[] {
  const results: FileResult[] = [];

  if (!fs.existsSync(dirPath)) {
    return results;
  }

  const items = fs.readdirSync(dirPath);

  for (const item of items) {
    if (excludeDirs.includes(item)) continue;
    if (SKIP_DIRECTORIES.has(item)) continue;

    const fullPath = path.join(dirPath, item);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      results.push(
        ...findFilesWithInsufficientBlankLines(fullPath, excludeDirs),
      );
    } else if (stat.isFile()) {
      const ext = path.extname(item);

      if (!SOURCE_EXTENSIONS.has(ext)) continue;
      if (shouldSkipFile(item)) continue;

      const stats = calculateBlankLineRatio(fullPath);

      // Only check files with meaningful content (at least 20 lines)
      if (stats.totalLines >= 20 && stats.ratio < MIN_BLANK_LINE_RATIO) {
        results.push({
          path: path.relative(projectRoot, fullPath),
          ratio: stats.ratio,
          blankLines: stats.blankLines,
          totalLines: stats.totalLines,
        });
      }
    }
  }

  return results;
}

function assertBlankLineRatio(dirPath: string): void {
  const insufficientFiles = findFilesWithInsufficientBlankLines(dirPath, [
    "node_modules",
  ]);

  if (insufficientFiles.length > 0) {
    const details = insufficientFiles
      .sort((a, b) => a.ratio - b.ratio)
      .map(
        (f) =>
          `  - ${f.path}: ${(f.ratio * 100).toFixed(1)}% blank (${f.blankLines}/${f.totalLines} lines)`,
      )
      .join("\n");

    expect.fail(
      `Found ${insufficientFiles.length} file(s) with less than ${MIN_BLANK_LINE_RATIO * 100}% blank lines:\n${details}\n\n` +
        `Add blank lines between logical sections to improve readability.`,
    );
  }

  expect(insufficientFiles).toHaveLength(0);
}

describe("Blank line requirements", () => {
  it.each([
    ["src/", ["src"]],
    ["webui/src/", ["webui", "src"]],
    ["scripts/", ["scripts"]],
  ])("should enforce minimum blank line ratio in %s", (_name, pathParts) => {
    const dirPath = path.join(projectRoot, ...pathParts);

    assertBlankLineRatio(dirPath);
    expect(true).toBe(true); // Satisfy vitest/expect-expect rule
  });
});
